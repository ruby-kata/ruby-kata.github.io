<!DOCTYPE html>
<html>
    <head>
        <title>Kata</title>
        <meta name="viewport" content="width=device-width,initial-scale=1">
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/6.65.7/codemirror.min.css">
        <link rel="stylesheet" href="./codekata.css">
        <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/6.65.7/codemirror.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/6.65.7/keymap/sublime.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/6.65.7/addon/comment/comment.min.js"></script>
        <script src="https://codemirror.net/mode/ruby/ruby.js"></script>
        <script type="module">
            import { DefaultRubyVM } from "https://cdn.jsdelivr.net/npm/@ruby/wasm-wasi@2.5.0/dist/browser/+esm";
            import { Application, Controller } from "https://unpkg.com/@hotwired/stimulus/dist/stimulus.js"

            window.Stimulus = Application.start()

            Stimulus.register("codekata", class extends Controller {
                connect() {
                    this.setup()
                }

                async setup() {
                    this.editor = CodeMirror.fromTextArea(document.getElementById('editor'), {
                        mode: "ruby",
                        lineNumbers: true,
                        keyMap: 'sublime',
                        extraKeys: {
                            "Alt-Up": "swapLineUp",
                            "Alt-Down": "swapLineDown",
                        }
                    });
                    // this.editor.save()
                    this.editor.setValue("def chop(num, arr)\nend")
                
                    const response = await fetch("https://cdn.jsdelivr.net/npm/@ruby/3.3-wasm-wasi@2.5.0/dist/ruby+stdlib.wasm");
                    const module = await WebAssembly.compileStreaming(response);
                    const { vm } = await DefaultRubyVM(module);
                    this.vm = vm
                }
                
                run() {
                    const code = this.editor.getValue()
                    const testcases = `
                        count = 0
                        cases = [
                            chop(3, []) == -1 ? (count += 1) && "assert_equal(-1, chop(3, [])) # OK" : "assert_equal(-1, chop(3, [])) # FAILED",
                            chop(3, [1]) == -1 ? (count += 1) && "assert_equal(-1, chop(3, [1])) # OK" : "assert_equal(-1, chop(3, [1])) # FAILED",
                            chop(1, [1]) == 0 ? (count += 1) && "assert_equal(0, chop(1, [1])) # OK" : "assert_equal(0, chop(1, [1])) # FAILED",
                            chop(1, [1, 3, 5]) == 0 ? (count += 1) && "assert_equal(0,  chop(1, [1, 3, 5])) # OK" : "assert_equal(0,  chop(1, [1, 3, 5])) # FAILED",
                            chop(3, [1, 3, 5]) == 1 ? (count += 1) && "assert_equal(1,  chop(3, [1, 3, 5])) # OK" : "assert_equal(1,  chop(3, [1, 3, 5])) # FAILED",
                            chop(5, [1, 3, 5]) == 2 ? (count += 1) && "assert_equal(2,  chop(5, [1, 3, 5])) # OK" : "assert_equal(2,  chop(5, [1, 3, 5])) # FAILED",
                            chop(0, [1, 3, 5]) == -1 ? (count += 1) && "assert_equal(-1,  chop(0, [1, 3, 5])) # OK" : "assert_equal(-1,  chop(0, [1, 3, 5])) # FAILED",
                            chop(2, [1, 3, 5]) == -1 ? (count += 1) && "assert_equal(-1,  chop(2, [1, 3, 5])) # OK" : "assert_equal(-1,  chop(2, [1, 3, 5])) # FAILED",
                            chop(4, [1, 3, 5]) == -1 ? (count += 1) && "assert_equal(-1,  chop(4, [1, 3, 5])) # OK" : "assert_equal(-1,  chop(4, [1, 3, 5])) # FAILED",
                            chop(6, [1, 3, 5]) == -1 ? (count += 1) && "assert_equal(-1,  chop(6, [1, 3, 5])) # OK" : "assert_equal(-1,  chop(6, [1, 3, 5])) # FAILED",
                            chop(1, [1, 3, 5, 7]) == 0 ? (count += 1) && "assert_equal(0,  chop(1, [1, 3, 5, 7])) # OK" : "assert_equal(0,  chop(1, [1, 3, 5, 7])) # FAILED",
                            chop(3, [1, 3, 5, 7]) == 1 ? (count += 1) && "assert_equal(1,  chop(3, [1, 3, 5, 7])) # OK" : "assert_equal(1,  chop(3, [1, 3, 5, 7])) # FAILED",
                            chop(5, [1, 3, 5, 7]) == 2 ? (count += 1) && "assert_equal(2,  chop(5, [1, 3, 5, 7])) # OK" : "assert_equal(2,  chop(5, [1, 3, 5, 7])) # FAILED",
                            chop(7, [1, 3, 5, 7]) == 3 ? (count += 1) && "assert_equal(3,  chop(7, [1, 3, 5, 7])) # OK" : "assert_equal(3,  chop(7, [1, 3, 5, 7])) # FAILED",
                            chop(-1, [1, 3, 5, 7]) == -1 ? (count += 1) && "assert_equal(-1,  chop(0, [1, 3, 5, 7])) # OK" : "assert_equal(-1,  chop(0, [1, 3, 5, 7])) # FAILED",
                            chop(-1, [1, 3, 5, 7]) == -1 ? (count += 1) && "assert_equal(-1,  chop(2, [1, 3, 5, 7])) # OK" : "assert_equal(-1,  chop(2, [1, 3, 5, 7])) # FAILED",
                            chop(-1, [1, 3, 5, 7]) == -1 ? (count += 1) && "assert_equal(-1,  chop(4, [1, 3, 5, 7])) # OK" : "assert_equal(-1,  chop(4, [1, 3, 5, 7])) # FAILED",
                            chop(-1, [1, 3, 5, 7]) == -1 ? (count += 1) && "assert_equal(-1,  chop(6, [1, 3, 5, 7])) # OK" : "assert_equal(-1,  chop(6, [1, 3, 5, 7])) # FAILED",
                            chop(-1, [1, 3, 5, 7]) == -1 ? (count += 1) && "assert_equal(-1,  chop(8, [1, 3, 5, 7])) # OK" : "assert_equal(-1,  chop(8, [1, 3, 5, 7])) # FAILED",
                        ]
                        cases.join('\n') + "\n--------------------------------------\nOK: #{count}, FAILED: #{cases.size - count}"
                    `

                    const result = this.vm.eval(`
                        begin
                            ${code}
                            ${testcases}
                        rescue => error
                            error
                        end
                    `);
                
                    document.getElementById('result').textContent = result
                }
            })
      </script> 
    </head>
  
    <body>
        <div data-controller="codekata" class="page">
            <textarea class="kata" readonly>
Kata02: Karate Chop
http://codekata.com/kata/kata02-karate-chop/
                
A binary chop (sometimes called the more prosaic binary search) finds the position of value in a sorted array of values. It achieves some efficiency by halving the number of items under consideration each time it probes the values: in the first pass it determines whether the required value is in the top or the bottom half of the list of values. In the second pass in considers only this half, again dividing it in to two. It stops when it finds the value it is looking for, or when it runs out of array to search. Binary searches are a favorite of CS lecturers.

This Kata is straightforward. Implement a binary search routine (using the specification below) in the language and technique of your choice. Tomorrow, implement it again, using a totally different technique. Do the same the next day, until you have five totally unique implementations of a binary chop. (For example, one solution might be the traditional iterative approach, one might be recursive, one might use a functional style passing array slices around, and so on).

Goals

This Kata has three separate goals:

1. As you’re coding each algorithm, keep a note of the kinds of error you encounter. A binary search is a ripe breeding ground for “off by one” and fencepost errors. As you progress through the week, see if the frequency of these errors decreases (that is, do you learn from experience in one technique when it comes to coding with a different technique?).

2. What can you say about the relative merits of the various techniques you’ve chosen? Which is the most likely to make it in to production code? Which was the most fun to write? Which was the hardest to get working? And for all these questions, ask yourself “why?”.

3. It’s fairly hard to come up with five unique approaches to a binary chop. How did you go about coming up with approaches four and five? What techniques did you use to fire those “off the wall” neurons?

Specification

Write a binary chop method that takes an integer search target and a sorted array of integers. It should return the integer index of the target in the array, or -1 if the target is not in the array. The signature will logically be:

`chop(int, array_of_int)  -> int`

You can assume that the array has less than 100,000 elements. For the purposes of this Kata, time and memory performance are not issues (assuming the chop terminates before you get bored and kill it, and that you have enough RAM to run it).
            </textarea>
            <div class="solution">
                <textarea id="editor"></textarea>
                <button data-action="click->codekata#run" class="run">run</button>
                <textarea id="result" class="result" readonly>
assert_equal(-1, chop(3, []))
assert_equal(-1, chop(3, [1]))
assert_equal(0,  chop(1, [1]))

assert_equal(0,  chop(1, [1, 3, 5]))
assert_equal(1,  chop(3, [1, 3, 5]))
assert_equal(2,  chop(5, [1, 3, 5]))
assert_equal(-1, chop(0, [1, 3, 5]))
assert_equal(-1, chop(2, [1, 3, 5]))
assert_equal(-1, chop(4, [1, 3, 5]))
assert_equal(-1, chop(6, [1, 3, 5]))

assert_equal(0,  chop(1, [1, 3, 5, 7]))
assert_equal(1,  chop(3, [1, 3, 5, 7]))
assert_equal(2,  chop(5, [1, 3, 5, 7]))
assert_equal(3,  chop(7, [1, 3, 5, 7]))
assert_equal(-1, chop(0, [1, 3, 5, 7]))
assert_equal(-1, chop(2, [1, 3, 5, 7]))
assert_equal(-1, chop(4, [1, 3, 5, 7]))
assert_equal(-1, chop(6, [1, 3, 5, 7]))
assert_equal(-1, chop(8, [1, 3, 5, 7]))

                </textarea>
            </div>
        </div>

        <div class="footer">
            <a href="./index.html">./ruby-kata-list</a><span>/karate-chop</span>
        </div>
    </body>
</html>